<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Autism Therapy Services Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css"/>
  <style>
    html, body { margin:0; padding:0; height:100%; }
    #map { height:100vh; width:100vw; }

    /* Search bar */
    #search-wrapper {
      position: fixed;
      top: 20px; left: 50%; transform: translateX(-50%);
      max-width: 600px; width: 80%;
      z-index: 1000;
    }
    #search-wrapper .leaflet-control-geocoder-form input {
      width: 100% !important;
      padding: 10px 14px;
      border-radius: 25px;
      font-size: 16px;
      border: 1px solid #ccc;
      box-shadow: 0 2px 6px rgba(0,0,0,0.25);
    }

    /* Side panel for results */
    #results {
      position: fixed;
      top: 80px; right: 20px;
      width: 340px; max-height: 65%;
      overflow-y: auto;
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      padding: 10px;
      z-index: 999;
      font-family: sans-serif;
    }
    #results h3 { margin:0 0 10px; font-size:18px; }
    #results .item {
      padding: 6px; margin-bottom: 6px;
      border-bottom: 1px solid #eee;
      cursor: pointer;
    }
    #results .item:hover { background:#f5f5f5; }

    /* Disclaimer box */
    #disclaimer {
      position: fixed;
      bottom: 10px; left: 50%; transform: translateX(-50%);
      width: 90%; max-width: 800px;
      background: rgba(255,255,255,0.9);
      border-radius: 8px;
      padding: 8px 12px;
      font-size: 12px;
      font-family: sans-serif;
      color: #444;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      z-index: 900;
    }
  </style>
</head>
<body>
  <div id="search-wrapper">
    <div id="search-container"></div>
  </div>
  <div id="map"></div>
  <div id="results" style="display:none">
    <h3>Nearby Services</h3>
    <div id="results-list"></div>
  </div>
  <div id="disclaimer">
    ‚ö†Ô∏è <b>Disclaimer:</b> This map displays therapy service locations using publicly available information. 
    Accuracy of addresses, phone numbers, and services is not guaranteed. Please contact providers directly to confirm details before visiting.
  </div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>

  <script>
    var map = L.map('map').setView([34.05, -118.25], 10);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '¬© OpenStreetMap contributors'
    }).addTo(map);

    var homeIcon = L.icon({
      iconUrl: "https://cdn-icons-png.flaticon.com/512/69/69524.png",
      iconSize: [38, 38], iconAnchor: [19, 38], popupAnchor: [0, -38]
    });

    var defaultMarkers = L.geoJSON(null, {
      onEachFeature: function (feature, layer) {
        layer.bindPopup("<b>" + feature.properties.Name + "</b><br/>" +
                        feature.properties.Address + "<br/>" +
                        (feature.properties.Phone || ""));
      }
    }).addTo(map);

    fetch('services.geojson')
      .then(res => res.json())
      .then(data => { defaultMarkers.addData(data); });

    // Keep search bar open, add placeholder text
    var geocoder = L.Control.geocoder({
      defaultMarkGeocode: false,
      collapsed: false,
      placeholder: "Enter your address or street intersection"
    }).addTo(map);
    var geocoderEl = document.querySelector('.leaflet-control-geocoder');
    document.getElementById('search-container').appendChild(geocoderEl);

    var searchMarker, bufferCircle;
    const ORS_API_KEY = "eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6Ijk2MDc5NzU5NjYzZjQyODQ4YTE3NGFmNTUzZWVjMGI2IiwiaCI6Im11cm11cjY0In0=";  // <--- Replace with your key

    // Function to get driving distance/time from ORS
    async function getDrivingDistance(start, end) {
      const url = `https://api.openrouteservice.org/v2/directions/driving-car?api_key=${ORS_API_KEY}&start=${start.lng},${start.lat}&end=${end.lng},${end.lat}`;
      try {
        let res = await fetch(url);
        if (!res.ok) throw new Error("ORS quota or network issue");
        let data = await res.json();
        let distMeters = data.routes[0].summary.distance;
        let durSeconds = data.routes[0].summary.duration;
        return {
          mode: "driving",
          distance: (distMeters / 1609.34).toFixed(2),
          duration: Math.round(durSeconds / 60)
        };
      } catch (err) {
        return null; // fallback
      }
    }

    geocoder.on('markgeocode', async function(e) {
      var latlng = e.geocode.center;
      if (searchMarker) map.removeLayer(searchMarker);
      if (bufferCircle) map.removeLayer(bufferCircle);

      searchMarker = L.marker(latlng, { icon: homeIcon }).addTo(map)
        .bindPopup("üè† " + e.geocode.name).openPopup();

      var miles = prompt("Enter buffer distance in miles:", "5");
      if (miles && !isNaN(miles)) {
        bufferCircle = L.circle(latlng, {
          radius: miles * 1609.34, color: 'blue', fillColor: '#cce5ff', fillOpacity: 0.2
        }).addTo(map);

        map.fitBounds(bufferCircle.getBounds());

        // Collect providers inside buffer
        var inside = [];
        var tasks = [];
        defaultMarkers.eachLayer(function(layer) {
          if (layer.getLatLng && bufferCircle.getBounds().contains(layer.getLatLng())) {
            tasks.push((async () => {
              let travel = await getDrivingDistance(latlng, layer.getLatLng());
              if (travel) {
                inside.push({ layer, dist: parseFloat(travel.distance), text: `üìè ${travel.distance} miles, ‚è± ${travel.duration} mins driving` });
              } else {
                // fallback: straight-line distance
                let distMeters = map.distance(latlng, layer.getLatLng());
                let distMiles = (distMeters / 1609.34).toFixed(2);
                inside.push({ layer, dist: parseFloat(distMiles), text: `üìè ${distMiles} miles (straight-line)` });
              }
            })());
          }
        });

        await Promise.all(tasks);

        // Sort by distance
        inside.sort((a, b) => a.dist - b.dist);

        // Update results panel
        var resultsDiv = document.getElementById('results');
        var resultsList = document.getElementById('results-list');
        resultsList.innerHTML = "";
        if (inside.length > 0) {
          resultsDiv.style.display = "block";
          inside.forEach(function(item) {
            var props = item.layer.feature.properties;
            var div = document.createElement('div');
            div.className = "item";
            div.innerHTML = `<b>${props.Name}</b><br/>${props.Address}<br/><small>${item.text}</small>`;
            div.onclick = function() {
              map.setView(item.layer.getLatLng(), 15);
              item.layer.openPopup();
            };
            resultsList.appendChild(div);
          });
        } else {
          resultsDiv.style.display = "none";
        }
      } else {
        map.setView(latlng, 12);
      }
    });
  </script>
</body>
</html>
